-- {-# LANGUAGE OverloadedStrings           #-}
-- {-# LANGUAGE TypeOperators               #-}
-- {-# LANGUAGE DataKinds                   #-}
-- {-# LANGUAGE FlexibleContexts            #-}
-- {-# LANGUAGE GeneralizedNewtypeDeriving  #-}
-- {-# LANGUAGE DuplicateRecordFields       #-}
-- {-# LANGUAGE NamedFieldPuns              #-}
-- {-# LANGUAGE RecordWildCards             #-}

module Ride.Client.Server where

-- import Control.Monad.Except (ExceptT (..), MonadError, runExceptT, liftEither, catchError, withExceptT )
-- import Data.Profunctor (lmap)
-- import Servant
--   ( Proxy (..)
--   , ServerT
--   , ServerError
--   , (:>)
--   , Get
--   , Post
--   , JSON 
--   , ReqBody
--   , throwError
--   , errBody
--   , err422
--   , err404
--   )
-- import Ride.App (AppT, logInfo)
-- -- import Ride.Client.DB (getClients, insertClient)
-- import Ride.Client.Class (Client (..), ClientError (..), CreateClient (..), createClient)
-- import Ride.User.Class (User (..), CreateUser (..), createUser)
-- import Ride.Shared.Types (Id (..))
-- import Ride.Shared.Utils (orThrow, toError)

-- import qualified Data.ByteString.Lazy.UTF8 as BS

-- type ClientAPI = "clients" :> ReqBody '[JSON] CreateClient :> Post '[JSON] Client

-- clientAPI :: Proxy ClientAPI
-- clientAPI = Proxy

-- clientServer :: MonadIO m => ServerT ClientAPI (AppT m)
-- clientServer = postClient

-- postClient :: MonadIO m => CreateClient -> AppT m Client
-- postClient clientArgs = do
--   client <- createClient clientArgs
--   either throwIO pure client
  -- client <- createClient clientArgs `orThrow` toError err422
  -- user   <- createAdmin client      `orThrow` toError err422
  -- insertClient client user
  -- pure (client, user)
  -- where
  --   createAdmin client = createUser $ CreateUser 
  --     { clientId = (clientId :: Client -> Id Client) client
  --     , email    = adminEmail clientArgs
  --     , password = adminPassword clientArgs
  --     , name     = adminName clientArgs
  --     }


